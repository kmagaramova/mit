//8) Каждую третью строку по убыванию, остальные по возрастанию с помощью сортировки слиянием.
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

ifstream in("inputmas.txt");
ofstream out("output.txt");

// Функция для слияния двух отсортированных подмассивов
void merge(vector<int>& arr, int l, int m, int r, bool a) {// лево,середина,право
    // Эта функция объединяет два отсортированных подмассива в один отсортированный массив.
    int n1 = m - l + 1; // Размер левого подмассива (от l до m).
    int n2 = r - m; // Размер правого подмассива (от m + 1 до r).

    vector<int> L(n1), R(n2); // Создаем два временных массива L и R для хранения левого и правого подмассивов.

    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i]; // Копируем элементы левого подмассива из arr в L.
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j]; // Копируем элементы правого подмассива из arr в R.
    int i = 0, j = 0, k = l; // Инициализируем индексы для обхода подмассивов L, R и исходного массива arr.
    // k - Индекс для записи в исходный массив arr.
    while (i < n1 && j < n2) { // Цикл для слияния двух подмассивов L и R в исходный массив arr.
        if ((a && L[i] <= R[j]) || (!a && L[i] >= R[j])) {
            arr[k] = L[i];
            i++; // Сравниваем элементы из L и R и записываем меньший (или больший, в зависимости от ascending) в arr.
        }
        else {
            arr[k] = R[j];
            j++; // Если условие выше не выполняется, записываем элемент из R в arr.
        }
        k++;
    }

    while (i < n1) { // Если в L остались элементы, копируем их в arr.
        arr[k] = L[i];
        i++;
        k++;//Переходим к следующим элементам.
    }

    while (j < n2) { // Если в R остались элементы, копируем их в arr.
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Функция для сортировки слиянием
void mergeSort(vector<int>& arr, int l, int r, bool a) { //Рекурсивно сортируем массив с использованием сортировки слиянием.
    if (l < r) { // Проверяем, нужно ли сортировать подмассив
        int m = l + (r - l) / 2; //Вычисляем середину, чтобы избежать переполнения.
        //сортируем левый и правый подмассивы и объединяем их в один.
        mergeSort(arr, l, m, a);
        mergeSort(arr, m + 1, r, a);
        merge(arr, l, m, r, a);
    }
}

int main() {
    int n;
    in >> n;
    vector<vector<int>> ms(n, vector<int>(n));

    for (int i = 0; i < n; ++i) {// Считываем матрицу из файла
        for (int j = 0; j < n; ++j) {
            in >> ms[i][j];
        }
    }
    for (int i = 0; i < n; ++i) { // Сортируем строки
        bool a = (i + 1) % 3 != 0; // Каждая третья строка сортируется по убыванию
        mergeSort(ms[i], 0, n - 1, a);
    }
    for (int i = 0; i < n; ++i) { // Записываем отсортированную матрицу в файл
        for (int j = 0; j < n; ++j) {
            out << setw(5) << ms[i][j] << " ";
        }
        out << endl;
    }
    in.close();
    out.close();
    return 0;
}