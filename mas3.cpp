//15) Диагонали, параллельные побочной по возрастанию с помощью сортировки вставками
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

ifstream in("inputmas.txt");
ofstream out("output.txt");

// Функция для сортировки вставками
void Sort(vector<int>& arr) {
    for (int i = 1; i < arr.size(); ++i) { // Цикл проходит по всем элементам массива, начиная со второго элемента, т к первый уже отсорт.
        int k = arr[i];// Сохраняем текущий элемент arr[i] в переменной k. 
        int j = i - 1; // Переменная j указывает на последний элемент отсортированной части массива.
        while (j >= 0 && arr[j] > k) { // цикл сдвигает элементы отсортированной части 
            //массива вправо, чтобы освободить место для вставки k.
            arr[j + 1] = arr[j]; // Сдвигаем элемент arr[j] на одну позицию вправо
            j--; // Переходим к предыдущему элементу в отсортированной части массива.
        }
        arr[j + 1] = k; //Вставляем сохраненный элемент key
    }
}

int main() {
    int n;
    in >> n;
    vector<vector<int>> ms(n, vector<int>(n));

    for (int i = 0; i < n; ++i) { // Считываем матрицу из файла
        for (int j = 0; j < n; ++j) {
            in >> ms[i][j];
        }
    }
    for (int k = 0; k < 2 * n - 1; ++k) { // Сортируем диагонали, параллельные побочной
        vector<int> d;
        for (int i = 0; i < n; ++i) { // цикл собирает элементы текущей диагонали в вектор diagonal.
            int j = k - i; // Индекс столбца, вычисляемый по формуле для диагонали с номером k.
            if (j >= 0 && j < n) { // Проверяем, что индекс столбца j находится в пределах матрицы.
                d.push_back(ms[i][j]); // добавляем
            }
        }
        Sort(d); // Сортирует элементы
        int index = 0; // записывает отсортированные элементы обратно в матрицу.
        for (int i = 0; i < n; ++i) {
            int j = k - i;
            if (j >= 0 && j < n) {
                ms[i][j] = d[index++]; // записывает отсортированные элементы из вектора diagonal обратно в матрицу.
            }
        }
    }
    for (int i = 0; i < n; ++i) { // Записываем отсортированную матрицу в файл
        for (int j = 0; j < n; ++j) {
            out << setw(5) << ms[i][j] << " ";
        }
        out << endl;
    }
    in.close();
    out.close();
    return 0;
}
